#+OPTIONS: toc:nil num: nil
#+TITLE: Raft

* Overview

[[https://raft.github.io/][Raft]] is a consensus algorithm. This version of raft uses ROS 2 and the
same functional methodology as RT-DDS (will link paper when
published). See the image below for how the servers are composed in a
pub-sub manner so that individual logic is handled at the marshall
layer.

[[file:raft.svg]]

* Structure

#+begin_src bash :exports results :results output raw :wrap src bash
source ~/.bashrc
ctree .                         # custom command
#+end_src

#+RESULTS:
#+begin_src bash
.
├── communication/ # handle transfer or data
├── data/ # e.g. RPC messages
├── functions/
│   ├── n-ary/ # i.e. if forall X, then do Y
│   │   ├── _candidate.py
│   │   ├── _follower.py
│   │   ├── _leader.py
│   │   └── server.py
│   └── unary/ # for handling messages
│       ├── marshall/ # outgoing
│       │   ├── request/
│       │   └── response/
│       └── unmarshall/ # incoming
│           ├── request/
│           │   ├── _client_cmd.py
│           │   ├── _request_append_entries.py
│           │   └── _request_vote.py
│           └── response/
└── state/ # server state
    ├── persistent.py
    └── volatile.py
#+end_src

* Pseudocode

Given the clear decomposition of functions (unary and n-ary), state,
data, and communication logic, each raft server operates with the
following logic:

#+begin_src python
for input in inputs:
    common_unmarshall(input)    # Check term, update self.term if <
    if input is response:
        unmarshall_parse(response, state)

n_ary = [follower, candidate, leader]

before = state.status
n_ary[before](state)
after = state.status

converted = (before != after)

if converted:
    n_ary[after](state)

for subscriber, corresponding_input in zip(subscribers, inputs)
    # Ok to ignore request if e.g. new leader sending append entries to old leader
    if corresponding_input is request and should_respond(state, corresponing_input):
        unmarshall_respond(request, state)
    else:
        if timeout_allows:
            marshall_request(subscriber, state)
#+end_src

* Tests

This repo also has a CLI parser which takes in arguments or a
~config.json~ which can configure:
 * ~num_servers: int~
 * ~scheduled_downtime: list[(server_index, start_ms, end_ms)]~
 * ~scheduled_config_change: list[(change, time)]~
 * ~scheduled_partition: list[(Set_A, set_B, ..., start_ms, end_ms)]~
 * ~writes: list[(int, time_ms)]~ for when the client writes a value
   change to the raft
